---
title: "Project 3: Bayesian Modeling of Hurricane Trajectories"
author: "Wenhao Gou, Qetsiyah Wang, Jared Klug, Michael Yan"
output: 
  pdf_document:
    fig_caption: true
---

```{r, include=FALSE, message=FALSE, warning=FALSE}
library(MASS)
library(tidyverse)
library(extraDistr)
library(matrixsampling)
library(caret)

data <-
  read_csv("./hurrican356.csv") %>% 
  janitor::clean_names() %>% 
  mutate(x1 = 1) %>%  # for the intercept
  rename(year = season) %>% 
  separate(time, into = c("date", "hour"), sep = " ") %>% 
  mutate(
    date = str_remove(date, "\\("),
    hour = str_remove(hour, "\\)")
  ) %>% 
  mutate(month = str_match(date, "-\\s*(.*?)\\s*-")) %>% 
  mutate(month = gsub("[-]", "", month)) %>% 
  filter(hour == "00:00:00" | hour == "06:00:00" | hour == "12:00:00" | hour == "18:00:00") %>% 
  mutate(
    hour = str_replace(hour, ":00:00", ""),
    hour = as.numeric(hour),
    month = month[,1],
    month = as.numeric(month),
    nature = as.numeric(as.factor(nature))
  )

ids <- unique(data$id)

dat <- list(NULL)

dfindex = 1
sumti = 0  # this value is for update sigma:=

i = 1
while (i <= length(ids)){
  subdata <-
    data %>% 
    filter(id == ids[i])
  rowcount <- nrow(subdata)
  # filter observations -> at least 5 observation so at
  # least 3 observations in the reminder. 
  if(rowcount < 5) {
    i = i + 1
  }else{
    # Count total number of hurricane and observation:
    sumti = sumti + rowcount  
    sub.wind = subdata$wind_kt
    sub.lat  = subdata$latitude
    sub.lon  = subdata$longitude
    
    dt1 = sub.wind[1:(rowcount-2)] - sub.wind[2:(rowcount - 1)]
    dt2 = sub.lat[1:(rowcount-2)] - sub.lat[2:(rowcount - 1)]
    dt3 = sub.lon[1:(rowcount-2)] - sub.lon[2:(rowcount - 1)]
    
    # Update the dat:
    redat = tibble(
      y = sub.wind[3:rowcount],
      intercept = 1,
      x1 = subdata$month[3:rowcount],
      x2 = subdata$year[3:rowcount],
      x3 = subdata$nature[3:rowcount],
      x4 = sub.wind[2:(rowcount - 1)],
      delta1 = dt1,
      delta2 = dt2,
      delta3 = dt3
    ) %>% as.matrix()
    
    dat[[dfindex]] = redat
    
    i = i + 1
    dfindex = dfindex + 1
  }
}



# functions for all posteria:

betai = function(dat, beta, sigmasq, big.sig.inv){
  res = vector("list", length = length(dat))
  # Beta_i function ~ N(V^-1*M, V^-1)
  for (i in 1:length(dat)){
    x = as.matrix(dat[[i]][,-1])
    y = as.vector(dat[[i]][,1])
    k = big.sig.inv + sigmasq^(-1) * t(x) %*% x
    m = sigmasq^(-1) * (t(y) %*% x)  + t(beta) %*% big.sig.inv
    varcov = solve(k)
    mu = varcov %*% t(m)
    bi = mvrnorm(1, mu = mu, Sigma = varcov)
    ssr = sum((y - x %*% bi)^2) # For calculating sigma
    res[[i]] = list(bi = bi, ssr = ssr)
  }
  bi2 = NULL
  ssr2 = NULL
  #return(res)
  for (ii in 1:length(res)){
    bi2 = rbind(bi2, res[[ii]]$bi)
    ssr2 = rbind(ssr2, res[[ii]]$ssr)
  }
  # Final beta.i is the 365x8 matrix 
  # SSR is the single value for calculating sigma
  return(list(beta.i = bi2, ssr = ssr2))
}

sigmasq = function(ssr){
  a = sumti/2 # Need re-check
  b = sum(ssr)/2
  sig = rinvgamma(1, alpha = a, beta = b) # single value 
  return(sig)}
# the updated is the sigma sq

bsig = function(betaimat, beta){
  v0 = nrow(betaimat) # n is number of hurrican
  # betai is a matrix for all beta.i
  
  summatrix <- diag(0,8,8)
  for(i in 1:nrow(betaimat)){
    beta.i <- betaimat[1,]
    summatrix <- summatrix + (beta.i - beta) %*% t(beta.i - beta)
  }
  
  s0 = summatrix + diag(1,8,8)
  bsig = rinvwishart(1, nu = v0, Omega = s0, checkSymmetry = F) # Covariance matrix 8x8 
  bsig = matrix(bsig,nrow = 8, ncol = 8)
  return(bsig)
}

beta.fun = function(betai, bigsig){
  ols = colMeans(betai)
  n = nrow(betai)
  beta = mvrnorm(1, mu = ols, Sigma = 1/n * solve(bigsig)) # vector 1x8
  return(beta)
}

# Implementation:

mcmc = function(dat, ini.beta, ini.bsig, ini.sig, niter = 1000){
  beta.i = vector("list", length = niter) # in each iteration, betai - 365x8
  b.sig = vector("list", length = niter)
  sigma = rep(NA, niter)
  beta = vector("list", length = niter)
  
  # Initial values:
  betaobj <- betai(dat, beta = ini.beta, sigma = ini.sig, big.sig = ini.bsig)
  beta.i[[1]] <- betaobj$beta
  sigma[1] <- ini.sig
  beta[[1]] <- ini.beta
  b.sig[[1]] <- ini.bsig
  
  # Do gibbs sampler
  for (i in 2:niter){
    betaobj <- betai(dat, beta = beta[[i-1]], sigma = sigma[i-1], big.sig = b.sig[[i-1]])
    beta.i[[i]] = betaobj$beta
    sigma[i] = sigmasq(ssr = betaobj$ssr)
    b.sig[[i]] = bsig(betai = beta.i[[i]], beta[[i-1]])
    beta[[i]] = beta.fun(betai = beta.i[[i]], bigsig = b.sig[[i]])
    #print(sigma[[i]])
  }
  return(list(beta.i = beta.i, sigma = sigma, b.sig = b.sig, beta = beta))
}

```

# Introduction
    Hierarchical Bayesian Model is the combination of two methods: 
    Linear Regression Model in Hierarchical Form and Bayesian Inference methods.
  
  Hierarchical form model is the linear regression model containing both Within-group analysis and Between-group analysis. Observations for each subject, from hierarchical form model, are usually collected with natural heterogeneity across the whole population over research time periods. This natural heterogeneity can be regarded as subject-specific mean response trajectories (i,e,. random effects) for each individual group. Nested data for each individual group violates the independent assumption for the linear regression model. Holding these individual-specific effects, the overall mean response over time across the whole research population is still considered as linearly over time, which is called Population-level effects (i.e,. fixed effects).
  $$\underbrace{\pi(\theta| X)}_{posterior\ distribution} \propto \underbrace{\pi(X|\theta)}_{likelihood} \times \underbrace{\pi(\theta)}_{prior\ distribution} $$
  Bayesian Inference is a statistical inference method about parameter. Before data collection, a proper prior distribution of parameter $\theta$ is set based on our belief about $\theta$. Then after data collection $\textbf{X} = (X_1, X_2,..., X_n)$, the belief of parameter $\theta$ would be updated by exploring the posterior distribution of $\theta$ based on observed data and its pre-assumed likelihood function $L(X; \theta)$. The  linear regression model in hierarchical form incorporating with Bayesian inference is implemented with Markov Chain Monte Carlo Integration algorithm for updating the parameter estimation in the final MCMC stationary phase.

# Objective
 In this project, we are going to explore whether the population-level changing trend of hurricane wind speed over years through a total of 356 groups of hurricanes. Each hurricane contained its own individual-level-specific effects. The hierarchical Bayesian model for the $\textit{i}$th hurricane is shown as
$$Y_i(t + 6) = \beta_{0,i} + X_{i_{Month}}\beta_{1,i} + X_{i_{Year}}\beta_{2,i} + X_{i_{Type}}\beta_{3,i} + X_{i_{Y_{i,t}(t)}}\beta_{4,i,t} + \Delta_{i,t_{lat}}\beta_{5,i,t} + \Delta_{i,t_{lon}}\beta_{6,i,t} + \Delta_{i,t_{Speed}}\beta_{7,i,t} + \epsilon_i(t),$$ 
where $i = 1,\ 2,..., m$ standing for each hurricane group and $t = 1,\ 2,..., t_i$ standing for each recorded time point within $\textit{i}$th hurricane group.

  The provided hierarchical Bayesian model for hurricane trajectories for $\textit{i}$th hurricane contains 4 population-level effects (i.e,. fixed): $X_{i_{Month}}$ - the month of year when hurricane started,  $X_{i_{Year}}$ - the calender year of the hurricane, $X_{i_{Type}}$ - the type of hurricane, and 4 individual-level- effects (i.e,. random): $X_{i_{Y_{i,ti}(t)}}$ - the $\textit{i}$th wind speed at $t - 1$ time point for t time point, $\Delta_{i,t_{lat}},\ \Delta_{i,t_{lon}},\ \Delta_{i,t_{Speed}}$ - the change of latitudes, longitudes and wind speeds between two recorded time points. 4 prior information are provided as following:
$$\boldsymbol{\beta_i} \sim N(\boldsymbol{\beta}, \Sigma^{-1}),\ \pi(\sigma^2) \propto \frac{1}{\sigma^2},$$
$$\pi(\boldsymbol{\beta}) \propto 1,\ \pi(\boldsymbol{\Sigma}^{-1}) \propto |\boldsymbol{\Sigma|}^{-(d + 1)/2}exp(-\frac{1}{2}\boldsymbol{\Sigma}^{-1}),$$
  Then our Hierarchical Bayesian Model for analyzing the trend of hurricane wind speed across years with considering all other covariates would be performed firstly by exploring estimated parameters from posterior distributions based on Bayes Theorem. 

# Hurricane Data
hurricane356.csv collected the track data of 356 hurricanes in the North Atlantic area since 1989. For all the storms, their location (longitude \& latitude) and maximum wind speed were recorded every 6 hours. The data includes the following variables 

1. **ID**: ID of the hurricanes
2. **Season**: In which \textbf{year} the hurricane occurred 
3. **Month**: In which \textbf{month} the hurricane occurred 
4. **Nature**: Nature of the hurricane 
  + ET: Extra Tropical
  + DS: Disturbance
  + NR: Not Rated
  + SS: Sub Tropical
  + TS: Tropical Storm
5. **time**: dates and time of the record  
6. **Latitude** and **Longitude**: The location of a hurricane check point 
7. **Wind.kt** Maximum wind speed (in Knot) at each check point 

# Posterior Distribution Inference and MCMC Methods

## Posterior Distribution Inference

 We have $\beta_i = (\beta_{0,i}, \beta_{1,i},..., \beta_{7,i,t})$ associated with the $\textit{i}$th hurricane. According to the knowledge of Multivariate Linear Regression Model, we know that $Y_{i,t} \sim N(X_{i,t}\beta_{i},\ \sigma^2I_{t_i})$, denoting, $\boldsymbol{\mu}_{i,t} = \textbf{X}_{i,t}\boldsymbol{\beta_i}$, 
  
Then we have,
$$\pi(\textbf{Y}_{i,t}|\boldsymbol{\mu}_{i,t}, \sigma^2, \boldsymbol{\beta}, \boldsymbol{\Sigma}^{-1}) \propto \frac{1}{\sqrt{\sigma^2}}exp{\{-\frac{1}{2}(\textbf{Y}_{i,t} - \boldsymbol{\mu}_{i,t})^T(\sigma^2I_{t_i})^{-1}(\textbf{Y}_{i,t} - \boldsymbol{\mu}_{i,t}) \}}$$

1. For $\pi(\boldsymbol{\beta_i}|.):$
\begin{align}
    \pi(\boldsymbol{\beta_i}|.) &\propto f(\boldsymbol{Y_i}|\boldsymbol{\beta_i}, \sigma^2) f(\boldsymbol{\beta_i}|\boldsymbol{\beta}, \boldsymbol{\Sigma}^{-1}) \\
    &\propto \bigg(\prod^{t_i}_{t=1}\frac{1}{\sqrt{\sigma^2}}exp \{-\frac{1}{2}(\textbf{Y}_{i,t} - \boldsymbol{\mu}_{i,t})^T(\sigma^2I_{t_i})^{-1}(\textbf{Y}_{i,t} - \boldsymbol{\mu}_{i,t})\}\bigg) \bigg({|\boldsymbol{\Sigma}|^{-1/2}} \exp \{ -\frac{1}{2} (\boldsymbol{\beta_i} - \boldsymbol{\beta})^T\boldsymbol{\Sigma^{-1}}(\boldsymbol{\beta_i} - \boldsymbol{\beta})\} \bigg) \\
    &\propto  \exp\{-\frac{1}{2}\bigg((\boldsymbol{Y_{i}} - \boldsymbol{X_{i}}\boldsymbol{\beta_i})^T(\sigma^{-2}\boldsymbol{I}_{t_i \times t_i})(\boldsymbol{Y_{i}} - \boldsymbol{X_{i}}\boldsymbol{\beta_i}) + (\boldsymbol{\beta_i}-\boldsymbol{\beta})^T\boldsymbol{\Sigma}^{-1}_{8 \times 8}(\boldsymbol{\beta_i} - \boldsymbol{\beta})\bigg)\} 
\end{align}

For the exponential term:
\begin{align}
&\;\;\;\;(\boldsymbol{Y_{i}} - \boldsymbol{X_{i}}\boldsymbol{\beta_i})^T(\sigma^{-2}\boldsymbol{I}_{t_i \times t_i})(\boldsymbol{Y_{i}} - \boldsymbol{X_{i}}\boldsymbol{\beta_i}) + (\boldsymbol{\beta_i}-\boldsymbol{\beta})^T\boldsymbol{\Sigma}^{-1}_{8 \times 8}(\boldsymbol{\beta_i} - \boldsymbol{\beta}) \\
&  = \boldsymbol{Y_i}^T \sigma^{-2} \boldsymbol{I}\boldsymbol{Y_i}^T  + \boldsymbol{\beta_i}^T\boldsymbol{X_i}^T\sigma^{-2} \boldsymbol{I}\boldsymbol{X_i}\boldsymbol{\beta_i} - 2 \boldsymbol{Y_i}^T \sigma^{-2}\boldsymbol{I}\boldsymbol{X_i}\boldsymbol{\beta_i}  \\
& \;\;\;\;\;+ \boldsymbol{\beta_i}^T\boldsymbol{\Sigma}^{-1}\boldsymbol{\beta_i} + \boldsymbol{\beta}^T\boldsymbol{\Sigma}^{-1}\boldsymbol{\beta} - 2\boldsymbol{\beta}^T\boldsymbol{\Sigma}^{-1}\boldsymbol{\beta_i} \\
& = \boldsymbol{Y_i}^T \sigma^{-2} \boldsymbol{I}\boldsymbol{Y_i}^T + \boldsymbol{\beta}^T\boldsymbol{\Sigma}^{-1}\boldsymbol{\beta} + \boldsymbol{\beta_i}^T(\boldsymbol{\Sigma}^{-1} + \boldsymbol{X_i}^T\sigma^{-2} \boldsymbol{I}\boldsymbol{X_i})\boldsymbol{\beta_i} \\
&\;\;\;\;\;-2(\boldsymbol{Y_i}^T\sigma^{-2}\boldsymbol{I}\boldsymbol{X_i} + \boldsymbol{\beta}^T\boldsymbol{\Sigma}^{-1})\boldsymbol{\beta_i} \\
& = \boldsymbol{R} + \boldsymbol{\beta_i}^T\boldsymbol{V}\boldsymbol{\beta_i} - 2\boldsymbol{M}\boldsymbol{\beta_i}
\end{align}

Where:
\begin{align}
    \boldsymbol{R} &= \boldsymbol{Y_i}^T \sigma^{-2}\boldsymbol{I}_{t_i \times t_i}\boldsymbol{Y_i} + \boldsymbol{\beta}^T\boldsymbol{\Sigma}^{-1}\boldsymbol{\beta}\\
    \boldsymbol{V} & = \boldsymbol{\Sigma}^{-1} + \sigma^{-2}\boldsymbol{X_i}^T\boldsymbol{X_i} \\
    \boldsymbol{M} & = \sigma^{-2}\boldsymbol{X_i}^T\boldsymbol{Y_i} + \boldsymbol{\Sigma}^{-1}\boldsymbol{\beta}
\end{align}

Then, the exponential term can be reduced to:
$$(\boldsymbol{\beta_i} - \boldsymbol{V^{-1}M})^T\boldsymbol{V}(\boldsymbol{\beta_i} - \boldsymbol{V^{-1}M})  - \boldsymbol{M}^{T}\boldsymbol{V^{-1}}\boldsymbol{M}^{T} + \boldsymbol{R}$$

We can ignore the latter 2 term as it is not related to $\boldsymbol{\beta_i}$. That indicate:
$$\pi(\boldsymbol{\beta_i}|.) \sim N(\boldsymbol{V^{-1}M}, \boldsymbol{V^{-1}})$$

2.For $\pi(\sigma^2|.):$
\begin{align}
    \pi(\sigma^2|.) & \propto f(\boldsymbol{Y}|\boldsymbol{\beta_i}, \sigma^2) \cdot \pi(\sigma^2) \\
    &\propto \bigg(\prod^n_{i=1}\prod^{t_i}_{t=1} \sigma^{-1}\exp\{{-\frac{(\boldsymbol{Y}_{i,t} - \boldsymbol{\mu}_{i,t})^2}{2\sigma^2}\}} \bigg)\frac{1}{\sigma^2}\\
    &\propto (\sigma^2)^{-1-\frac{\sum t_i}{2}}\prod^n_{i=1}\prod^{t_i}_{t=1} \exp\{{-\frac{(\boldsymbol{Y}_{i,t} - \boldsymbol{\mu}_{i,t})^2}{2\sigma^2}\}} \\
    &\propto \sigma^{-2-\sum t_i}\exp{\{-\frac{1}{2\sigma^2}\sum^n_{i=1}\sum^{ti}_{t=1}(\boldsymbol{Y}_{i,t} - \boldsymbol{\mu}_{i,t})^2\}} 
\end{align}

So:  
$$\sigma^2 \sim \text{Inverse Gamma}(\frac{1}{2}\sum_{i=1}^n t_i, \frac{1}{2}\sum^n_{i=1}\sum^{ti}_{t=1}(\boldsymbol{Y}_{i,t} - \boldsymbol{\mu}_{i,t})^2)$$

3. For $\pi(\boldsymbol{\Sigma}^{-1}|.)$:
We have the prior of $\pi(\boldsymbol{\Sigma^{-1}}) \sim |\boldsymbol{\Sigma|}^{-(d+1)/2}exp(-\frac{1}{2}\boldsymbol{\Sigma}^{-1})$, which actually follows the Inverse Wishart distribution $(\boldsymbol{\Sigma^{-1}})\sim \text{Inverse Wishart}(v_0, S_0), \text{where}\ v_0 = 0, S_0 = 1$
\begin{align}
    \pi(\boldsymbol{\Sigma}^{-1}|.) &\propto f(\boldsymbol{\beta_i}|\boldsymbol{\beta}, \boldsymbol{\Sigma}^{-1})f(\boldsymbol{\Sigma}^{-1}) \\
    &\propto \bigg(\prod^n_{i=1}\boldsymbol{\Sigma}^{-\frac{1}{2}} \exp\{-\frac{1}{2}(\boldsymbol{\beta_i}-\boldsymbol{\beta})^T\boldsymbol{\Sigma}^{-1}(\boldsymbol{\beta_i}-\boldsymbol{\beta}) \} \bigg) |\boldsymbol{\Sigma}|^{-(d-1)/2} \exp\{-\frac{1}{2}\boldsymbol{\Sigma}^{-1}\} \\
    &\propto |\boldsymbol{\Sigma}|^{-(n+d+1)/2} \exp\{-\frac{1}{2}tr(\boldsymbol{\Sigma^{-1}})-\frac{1}{2}\sum^n_{i=1}(\boldsymbol{\beta_i}-\boldsymbol{\beta})^T\boldsymbol{\Sigma}^{-1}(\boldsymbol{\beta_i}-\boldsymbol{\beta})\} \\
    &\propto |\boldsymbol{\Sigma}|^{-(n+d+1)/2} \exp \{ -\frac{1}{2}tr\bigg(\boldsymbol{\Sigma^{-1}}(\boldsymbol{I} + \sum_{i=1}^{n}(\boldsymbol{\beta_i}-\boldsymbol{\beta})(\boldsymbol{\beta_i}-\boldsymbol{\beta})^{T})\bigg)\}
\end{align}

That indicate: 
$$\boldsymbol{\Sigma}^{-1} \sim \text{Inverse Whishart}\bigg(n,\boldsymbol{I} + \sum_{i=1}^{n}(\boldsymbol{\beta_i}-\boldsymbol{\beta})^T(\boldsymbol{\beta_i}-\boldsymbol{\beta})\bigg)$$

4. For $\pi(\boldsymbol{\beta}|.)$: 
\begin{align}
    \pi(\boldsymbol{\beta}|.) &\propto f(\boldsymbol{\beta_i}|\boldsymbol{\beta}, \boldsymbol{\Sigma}^{-1})f(\boldsymbol{\beta}) \\
    &\propto \bigg(\prod^n_{i=1} \exp\{-\frac{1}{2}(\boldsymbol{\beta_i}-\boldsymbol{\beta})^T\boldsymbol{\Sigma}^{-1}(\boldsymbol{\beta_i}-\boldsymbol{\beta}) \} \bigg) \\
    &\propto \exp \{ -\frac{1}{2}\bigg(\sum_{i = 1}^{n} (\boldsymbol{\beta_i}-\boldsymbol{\beta})^T\boldsymbol{\Sigma}^{-1}(\boldsymbol{\beta_i}-\boldsymbol{\beta})\bigg)\} \\
    &\propto \exp \{-\frac{1}{2}\bigg(\sum_{i = 1}^{n} \boldsymbol{\beta_i}^T\boldsymbol{\Sigma}^{-1}\boldsymbol{\beta_i}+\boldsymbol{\beta}^Tn\boldsymbol{\Sigma}^{-1}\boldsymbol{\beta}-\sum_{i = 1}^{n}2\boldsymbol{\beta_i}^T\boldsymbol{\Sigma^{-1}}\boldsymbol{\beta}\bigg)\}
\end{align}

For the exponential term, if we set: 
\begin{align}
    \boldsymbol{V} &= n\boldsymbol{\Sigma}^{-1} \\
    \boldsymbol{R} &= \sum_{i = 1}^{n} \boldsymbol{\beta_i}^T\boldsymbol{\Sigma}^{-1}\boldsymbol{\beta_i} \\
    \boldsymbol{M} &= \sum_{i = 1}^{n}\bigg(\boldsymbol{\Sigma}^{-1}\boldsymbol{\beta_i}\bigg) 
\end{align}

Then, use the same technique when generating $\boldsymbol{\beta_i}$
$$R + \boldsymbol{\beta}\boldsymbol{V}
\boldsymbol{\beta} - 2\boldsymbol{M}\boldsymbol{\beta} \propto (\boldsymbol{\beta} - \boldsymbol{V}^{-1}\boldsymbol{M})^{T}\boldsymbol{V}^{-1}(\boldsymbol{\beta} - \boldsymbol{V}^{-1}\boldsymbol{M})$$

(NOTE: This is the same as using OLS to estimate $\boldsymbol{\beta}$ using all $\boldsymbol{\beta_i}$)

That indicate: 

$$\boldsymbol{\beta} \sim N \bigg(Vec(\hat{\beta_i}), \boldsymbol{\Sigma}\ \beta_i^T\beta_i\bigg)$$



# Results and dicussion
## Test the chain with the first set of initial value
```{r, include=FALSE, message=FALSE, warning=FALSE}
# Test the chain
### first set of initial value
test <- mcmc(dat, 
             ini.beta = c(50,rep(0,7)), 
             ini.sig = .5, 
             ini.bsig = diag(.5,8,8), niter = 1000)

summaryplotsfun <- function(input_chain){
  betasummary <- tibble(
    intercept = 0,
    x1 = 0,
    x2 = 0,
    x3 = 0,
    x4 = 0,
    delta1 = 0,
    delta2 = 0,
    delta3 = 0) %>% slice(-1)
  
  for (i in 1:length(input_chain$beta)){
    sub <- t(input_chain$beta[[i]]) %>% as.data.frame()
    names(sub) <- names(betasummary)
    betasummary <- bind_rows(betasummary,sub)
  }
  
  betasummary  <- 
    betasummary %>% 
    dplyr::select(1:8) %>% 
    mutate(index = 1:(nrow(betasummary))) %>% 
    pivot_longer(1:8,
                 names_to = "var",
                 values_to = "val")
  
  p1 <- betasummary %>% 
    ggplot(aes(x = val, group = var, color = var)) + 
    geom_histogram() +
    facet_wrap(~var, nrow = 2, scales = "free")
  
  p2 <- betasummary %>% 
    ggplot(aes(x = index, y = val, group = var, color = var)) + 
    geom_line() +
    facet_wrap(~var, nrow = 2, scales = "free")
  
  return(list(p1=p1,p2=p2))
}
```

```{r}
summary1 <- summaryplotsfun(test)
summary1[[1]]
summary1[[2]]
```


After testing the chain with the first set of initial values, from the density plots, we noticed that for all variables except the intercept, they follow a normal distribution. From the line chart, we see that all variables converged except for the intercept. Therefore, we decided to do a warm start to see whether the problem is solved.


## Test the chain with a warm start
```{r, include=FALSE, message=FALSE, warning=FALSE}
#warm start
warm_df = read.csv("./hurrican356.csv") %>% 
  janitor::clean_names() %>% 
  rename(year = season) %>% 
  separate(time, into = c("date", "hour"), sep = " ") %>% 
  dplyr::mutate(
    date = str_remove(date, "\\("),
    hour = str_remove(hour, "\\)")
  ) %>% 
  dplyr::mutate(month = str_match(date, "-\\s*(.*?)\\s*-")) %>% 
  dplyr::mutate(month = gsub("[-]", "", month)) %>% 
  dplyr::mutate(
    hour = str_replace(hour, ":00:00", ""),
    month = month[,1],
    month = as.numeric(month)
  ) %>% 
  group_by(id) %>% 
  dplyr::mutate(
    delta1 = c(NA, diff(latitude)),
    delta2 = c(NA, diff(longitude)),
    delta3 = c(NA, diff(wind_kt)),
    x4 = lag(wind_kt)
  ) %>% 
  ungroup() %>% 
  na.omit() %>% 
  dplyr::select(id, month, year, nature, x4, delta1, delta2, delta3, latitude, longitude, wind_kt)

x <- model.matrix(wind_kt ~ month + year + as.factor(nature) + x4 + delta1 + delta2 + delta3, data = warm_df)
y = warm_df$wind_kt

ctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 5)

fit.lm <- train(x, y, 
                method = "lm",
                trControl = ctrl)

warm_beta = c(coef(fit.lm$finalModel)[1], coef(fit.lm$finalModel)[3], coef(fit.lm$finalModel)[4],
              mean(coef(fit.lm$finalModel)[5:8]),coef(fit.lm$finalModel)[9], coef(fit.lm$finalModel)[10],
              coef(fit.lm$finalModel)[11],coef(fit.lm$finalModel)[12])

test2 <- mcmc(dat, 
              ini.beta = warm_beta, 
              ini.sig = 1, 
              ini.bsig = diag(1,8,8), niter = 1000)
```

```{r}
summary2 <- summaryplotsfun(test2)
summary2[[1]]
summary2[[2]]
```


By doing warm start, for the intercept, it's density plot appeared to be a mixture of 2 normal distributions, suggesting that we need to subset the data. The line chart still shows no convergence. The nature of the wind speed is: go up first and go down. So we separate it into up intervals and down intervals as one of our predictor, delta3.


## Test the chain with subsetted data
```{r, include=FALSE, message=FALSE, warning=FALSE}
###### NEW ########
# Try subsetting the data:
datup <- data %>% slice(1) %>% slice(-1)
datdown <- data %>% slice(1) %>% slice(-1)

# Split into up and down:

for(i in 1:length(ids)){
  subdf = 
    data %>% 
    filter(id == ids[i])
  
  # identify max windspeed:
  index <- which.max(subdf$wind_kt)
  
  datup <- bind_rows(datup, subdf[1:index,])
  datdown <- bind_rows(datdown, subdf[index:nrow(subdf),])
}


dat <- list(NULL)

dfindex = 1
sumti = 0  # this value is for update sigma:= = as we sub-seted we need to run again.

i = 1
while (i <= length(ids)){
  subdata <-
    datup %>%    # !modify for up!
    filter(id == ids[i])
  rowcount <- nrow(subdata)
  # filter observations -> at least 5 observation so at
  # least 3 observations in the reminder. 
  if(rowcount < 5) {
    i = i + 1
  }else{
    # Count total number of hurricane and observation:
    sumti = sumti + rowcount  
    sub.wind = subdata$wind_kt
    sub.lat  = subdata$latitude
    sub.lon  = subdata$longitude
    
    dt1 = sub.wind[1:(rowcount-2)] - sub.wind[2:(rowcount - 1)]
    dt2 = sub.lat[1:(rowcount-2)] - sub.lat[2:(rowcount - 1)]
    dt3 = sub.lon[1:(rowcount-2)] - sub.lon[2:(rowcount - 1)]
    
    # Update the dat:
    redat = tibble(
      y = sub.wind[3:rowcount],
      intercept = 1,
      x1 = subdata$month[3:rowcount],
      x2 = subdata$year[3:rowcount],
      x3 = subdata$nature[3:rowcount],
      x4 = sub.wind[2:(rowcount - 1)],
      delta1 = dt1,
      delta2 = dt2,
      delta3 = dt3
    ) %>% as.matrix()
    
    dat[[dfindex]] = redat
    
    i = i + 1
    dfindex = dfindex + 1
  }
}

upchain <- mcmc(dat, 
                ini.beta = rep(5,8), 
                ini.sig = 1, 
                ini.bsig = diag(1,8,8), niter = 3000)

#### downchain

dat <- list(NULL)
dfindex = 1
sumti = 0  # this value is for update sigma:= = as we sub-seted we need to run again.

i = 1
while (i <= length(ids)){
  subdata <-
    datdown %>%    # !modify for dwon!
    filter(id == ids[i])
  rowcount <- nrow(subdata)
  # filter observations -> at least 5 observation so at
  # least 3 observations in the reminder. 
  if(rowcount < 5) {
    i = i + 1
  }else{
    # Count total number of hurricane and observation:
    sumti = sumti + rowcount  
    sub.wind = subdata$wind_kt
    sub.lat  = subdata$latitude
    sub.lon  = subdata$longitude
    
    dt1 = sub.wind[1:(rowcount-2)] - sub.wind[2:(rowcount - 1)]
    dt2 = sub.lat[1:(rowcount-2)] - sub.lat[2:(rowcount - 1)]
    dt3 = sub.lon[1:(rowcount-2)] - sub.lon[2:(rowcount - 1)]
    
    # Update the dat:
    redat = tibble(
      y = sub.wind[3:rowcount],
      intercept = 1,
      x1 = subdata$month[3:rowcount],
      x2 = subdata$year[3:rowcount],
      x3 = subdata$nature[3:rowcount],
      x4 = sub.wind[2:(rowcount - 1)],
      delta1 = dt1,
      delta2 = dt2,
      delta3 = dt3
    ) %>% as.matrix()
    
    dat[[dfindex]] = redat
    
    i = i + 1
    dfindex = dfindex + 1
  }
}

downchain <- mcmc(dat, 
                  ini.beta = rep(5,8), 
                  ini.sig = 1, 
                  ini.bsig = diag(1,8,8), niter = 5000)
```

## Plots for upchain
```{r}
summaryup <- summaryplotsfun(upchain)
summaryup[[1]]
summaryup[[2]]
```

## Plots for downchain
```{r}
summarydown <- summaryplotsfun(downchain)
summarydown[[1]]
summarydown[[2]]
```


The “upchain” (wind speed increasing monotonically) actually converged in about 2k-3k steps but the "downchain" did not seems to converge. This may due to a bad prior.



